{"version":3,"file":"bundle.js","sources":["../node_modules/jsfxr/jsfxr.js"],"sourcesContent":["/**\n * SfxrParams\n *\n * Copyright 2010 Thomas Vian\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author Thomas Vian\n */\n/** @constructor */\nfunction SfxrParams() {\n  //--------------------------------------------------------------------------\n  //\n  //  Settings String Methods\n  //\n  //--------------------------------------------------------------------------\n\n  /**\n   * Parses a settings array into the parameters\n   * @param array Array of the settings values, where elements 0 - 23 are\n   *                a: waveType\n   *                b: attackTime\n   *                c: sustainTime\n   *                d: sustainPunch\n   *                e: decayTime\n   *                f: startFrequency\n   *                g: minFrequency\n   *                h: slide\n   *                i: deltaSlide\n   *                j: vibratoDepth\n   *                k: vibratoSpeed\n   *                l: changeAmount\n   *                m: changeSpeed\n   *                n: squareDuty\n   *                o: dutySweep\n   *                p: repeatSpeed\n   *                q: phaserOffset\n   *                r: phaserSweep\n   *                s: lpFilterCutoff\n   *                t: lpFilterCutoffSweep\n   *                u: lpFilterResonance\n   *                v: hpFilterCutoff\n   *                w: hpFilterCutoffSweep\n   *                x: masterVolume\n   * @return If the string successfully parsed\n   */\n  this.setSettings = function(values)\n  {\n    for ( var i = 0; i < 24; i++ )\n    {\n      this[String.fromCharCode( 97 + i )] = values[i] || 0;\n    }\n\n    // I moved this here from the reset(true) function\n    if (this['c'] < .01) {\n      this['c'] = .01;\n    }\n\n    var totalTime = this['b'] + this['c'] + this['e'];\n    if (totalTime < .18) {\n      var multiplier = .18 / totalTime;\n      this['b']  *= multiplier;\n      this['c'] *= multiplier;\n      this['e']   *= multiplier;\n    }\n  }\n}\n\n/**\n * SfxrSynth\n *\n * Copyright 2010 Thomas Vian\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author Thomas Vian\n */\n/** @constructor */\nfunction SfxrSynth() {\n  // All variables are kept alive through function closures\n\n  //--------------------------------------------------------------------------\n  //\n  //  Sound Parameters\n  //\n  //--------------------------------------------------------------------------\n\n  this._params = new SfxrParams();  // Params instance\n\n  //--------------------------------------------------------------------------\n  //\n  //  Synth Variables\n  //\n  //--------------------------------------------------------------------------\n\n  var _envelopeLength0, // Length of the attack stage\n      _envelopeLength1, // Length of the sustain stage\n      _envelopeLength2, // Length of the decay stage\n\n      _period,          // Period of the wave\n      _maxPeriod,       // Maximum period before sound stops (from minFrequency)\n\n      _slide,           // Note slide\n      _deltaSlide,      // Change in slide\n\n      _changeAmount,    // Amount to change the note by\n      _changeTime,      // Counter for the note change\n      _changeLimit,     // Once the time reaches this limit, the note changes\n\n      _squareDuty,      // Offset of center switching point in the square wave\n      _dutySweep;       // Amount to change the duty by\n\n  //--------------------------------------------------------------------------\n  //\n  //  Synth Methods\n  //\n  //--------------------------------------------------------------------------\n\n  /**\n   * Resets the runing variables from the params\n   * Used once at the start (total reset) and for the repeat effect (partial reset)\n   */\n  this.reset = function() {\n    // Shorter reference\n    var p = this._params;\n\n    _period       = 100 / (p['f'] * p['f'] + .001);\n    _maxPeriod    = 100 / (p['g']   * p['g']   + .001);\n\n    _slide        = 1 - p['h'] * p['h'] * p['h'] * .01;\n    _deltaSlide   = -p['i'] * p['i'] * p['i'] * .000001;\n\n    if (!p['a']) {\n      _squareDuty = .5 - p['n'] / 2;\n      _dutySweep  = -p['o'] * .00005;\n    }\n\n    _changeAmount =  1 + p['l'] * p['l'] * (p['l'] > 0 ? -.9 : 10);\n    _changeTime   = 0;\n    _changeLimit  = p['m'] == 1 ? 0 : (1 - p['m']) * (1 - p['m']) * 20000 + 32;\n  }\n\n  // I split the reset() function into two functions for better readability\n  this.totalReset = function() {\n    this.reset();\n\n    // Shorter reference\n    var p = this._params;\n\n    // Calculating the length is all that remained here, everything else moved somewhere\n    _envelopeLength0 = p['b']  * p['b']  * 100000;\n    _envelopeLength1 = p['c'] * p['c'] * 100000;\n    _envelopeLength2 = p['e']   * p['e']   * 100000 + 12;\n    // Full length of the volume envelop (and therefore sound)\n    // Make sure the length can be divided by 3 so we will not need the padding \"==\" after base64 encode\n    return ((_envelopeLength0 + _envelopeLength1 + _envelopeLength2) / 3 | 0) * 3;\n  }\n\n  /**\n   * Writes the wave to the supplied buffer ByteArray\n   * @param buffer A ByteArray to write the wave to\n   * @return If the wave is finished\n   */\n  this.synthWave = function(buffer, length) {\n    // Shorter reference\n    var p = this._params;\n\n    // If the filters are active\n    var _filters = p['s'] != 1 || p['v'],\n        // Cutoff multiplier which adjusts the amount the wave position can move\n        _hpFilterCutoff = p['v'] * p['v'] * .1,\n        // Speed of the high-pass cutoff multiplier\n        _hpFilterDeltaCutoff = 1 + p['w'] * .0003,\n        // Cutoff multiplier which adjusts the amount the wave position can move\n        _lpFilterCutoff = p['s'] * p['s'] * p['s'] * .1,\n        // Speed of the low-pass cutoff multiplier\n        _lpFilterDeltaCutoff = 1 + p['t'] * .0001,\n        // If the low pass filter is active\n        _lpFilterOn = p['s'] != 1,\n        // masterVolume * masterVolume (for quick calculations)\n        _masterVolume = p['x'] * p['x'],\n        // Minimum frequency before stopping\n        _minFreqency = p['g'],\n        // If the phaser is active\n        _phaser = p['q'] || p['r'],\n        // Change in phase offset\n        _phaserDeltaOffset = p['r'] * p['r'] * p['r'] * .2,\n        // Phase offset for phaser effect\n        _phaserOffset = p['q'] * p['q'] * (p['q'] < 0 ? -1020 : 1020),\n        // Once the time reaches this limit, some of the    iables are reset\n        _repeatLimit = p['p'] ? ((1 - p['p']) * (1 - p['p']) * 20000 | 0) + 32 : 0,\n        // The punch factor (louder at begining of sustain)\n        _sustainPunch = p['d'],\n        // Amount to change the period of the wave by at the peak of the vibrato wave\n        _vibratoAmplitude = p['j'] / 2,\n        // Speed at which the vibrato phase moves\n        _vibratoSpeed = p['k'] * p['k'] * .01,\n        // The type of wave to generate\n        _waveType = p['a'];\n\n    var _envelopeLength      = _envelopeLength0,     // Length of the current envelope stage\n        _envelopeOverLength0 = 1 / _envelopeLength0, // (for quick calculations)\n        _envelopeOverLength1 = 1 / _envelopeLength1, // (for quick calculations)\n        _envelopeOverLength2 = 1 / _envelopeLength2; // (for quick calculations)\n\n    // Damping muliplier which restricts how fast the wave position can move\n    var _lpFilterDamping = 5 / (1 + p['u'] * p['u'] * 20) * (.01 + _lpFilterCutoff);\n    if (_lpFilterDamping > .8) {\n      _lpFilterDamping = .8;\n    }\n    _lpFilterDamping = 1 - _lpFilterDamping;\n\n    var _finished = false,     // If the sound has finished\n        _envelopeStage    = 0, // Current stage of the envelope (attack, sustain, decay, end)\n        _envelopeTime     = 0, // Current time through current enelope stage\n        _envelopeVolume   = 0, // Current volume of the envelope\n        _hpFilterPos      = 0, // Adjusted wave position after high-pass filter\n        _lpFilterDeltaPos = 0, // Change in low-pass wave position, as allowed by the cutoff and damping\n        _lpFilterOldPos,       // Previous low-pass wave position\n        _lpFilterPos      = 0, // Adjusted wave position after low-pass filter\n        _periodTemp,           // Period modified by vibrato\n        _phase            = 0, // Phase through the wave\n        _phaserInt,            // Integer phaser offset, for bit maths\n        _phaserPos        = 0, // Position through the phaser buffer\n        _pos,                  // Phase expresed as a Number from 0-1, used for fast sin approx\n        _repeatTime       = 0, // Counter for the repeats\n        _sample,               // Sub-sample calculated 8 times per actual sample, averaged out to get the super sample\n        _superSample,          // Actual sample writen to the wave\n        _vibratoPhase     = 0; // Phase through the vibrato sine wave\n\n    // Buffer of wave values used to create the out of phase second wave\n    var _phaserBuffer = new Array(1024),\n        // Buffer of random values used to generate noise\n        _noiseBuffer  = new Array(32);\n    for (var i = _phaserBuffer.length; i--; ) {\n      _phaserBuffer[i] = 0;\n    }\n    for (var i = _noiseBuffer.length; i--; ) {\n      _noiseBuffer[i] = Math.random() * 2 - 1;\n    }\n\n    for (var i = 0; i < length; i++) {\n      if (_finished) {\n        return i;\n      }\n\n      // Repeats every _repeatLimit times, partially resetting the sound parameters\n      if (_repeatLimit) {\n        if (++_repeatTime >= _repeatLimit) {\n          _repeatTime = 0;\n          this.reset();\n        }\n      }\n\n      // If _changeLimit is reached, shifts the pitch\n      if (_changeLimit) {\n        if (++_changeTime >= _changeLimit) {\n          _changeLimit = 0;\n          _period *= _changeAmount;\n        }\n      }\n\n      // Acccelerate and apply slide\n      _slide += _deltaSlide;\n      _period *= _slide;\n\n      // Checks for frequency getting too low, and stops the sound if a minFrequency was set\n      if (_period > _maxPeriod) {\n        _period = _maxPeriod;\n        if (_minFreqency > 0) {\n          _finished = true;\n        }\n      }\n\n      _periodTemp = _period;\n\n      // Applies the vibrato effect\n      if (_vibratoAmplitude > 0) {\n        _vibratoPhase += _vibratoSpeed;\n        _periodTemp *= 1 + Math.sin(_vibratoPhase) * _vibratoAmplitude;\n      }\n\n      _periodTemp |= 0;\n      if (_periodTemp < 8) {\n        _periodTemp = 8;\n      }\n\n      // Sweeps the square duty\n      if (!_waveType) {\n        _squareDuty += _dutySweep;\n        if (_squareDuty < 0) {\n          _squareDuty = 0;\n        } else if (_squareDuty > .5) {\n          _squareDuty = .5;\n        }\n      }\n\n      // Moves through the different stages of the volume envelope\n      if (++_envelopeTime > _envelopeLength) {\n        _envelopeTime = 0;\n\n        switch (++_envelopeStage)  {\n          case 1:\n            _envelopeLength = _envelopeLength1;\n            break;\n          case 2:\n            _envelopeLength = _envelopeLength2;\n        }\n      }\n\n      // Sets the volume based on the position in the envelope\n      switch (_envelopeStage) {\n        case 0:\n          _envelopeVolume = _envelopeTime * _envelopeOverLength0;\n          break;\n        case 1:\n          _envelopeVolume = 1 + (1 - _envelopeTime * _envelopeOverLength1) * 2 * _sustainPunch;\n          break;\n        case 2:\n          _envelopeVolume = 1 - _envelopeTime * _envelopeOverLength2;\n          break;\n        case 3:\n          _envelopeVolume = 0;\n          _finished = true;\n      }\n\n      // Moves the phaser offset\n      if (_phaser) {\n        _phaserOffset += _phaserDeltaOffset;\n        _phaserInt = _phaserOffset | 0;\n        if (_phaserInt < 0) {\n          _phaserInt = -_phaserInt;\n        } else if (_phaserInt > 1023) {\n          _phaserInt = 1023;\n        }\n      }\n\n      // Moves the high-pass filter cutoff\n      if (_filters && _hpFilterDeltaCutoff) {\n        _hpFilterCutoff *= _hpFilterDeltaCutoff;\n        if (_hpFilterCutoff < .00001) {\n          _hpFilterCutoff = .00001;\n        } else if (_hpFilterCutoff > .1) {\n          _hpFilterCutoff = .1;\n        }\n      }\n\n      _superSample = 0;\n      for (var j = 8; j--; ) {\n        // Cycles through the period\n        _phase++;\n        if (_phase >= _periodTemp) {\n          _phase %= _periodTemp;\n\n          // Generates new random noise for this period\n          if (_waveType == 3) {\n            for (var n = _noiseBuffer.length; n--; ) {\n              _noiseBuffer[n] = Math.random() * 2 - 1;\n            }\n          }\n        }\n\n        // Gets the sample from the oscillator\n        switch (_waveType) {\n          case 0: // Square wave\n            _sample = ((_phase / _periodTemp) < _squareDuty) ? .5 : -.5;\n            break;\n          case 1: // Saw wave\n            _sample = 1 - _phase / _periodTemp * 2;\n            break;\n          case 2: // Sine wave (fast and accurate approx)\n            _pos = _phase / _periodTemp;\n            _pos = (_pos > .5 ? _pos - 1 : _pos) * 6.28318531;\n            _sample = 1.27323954 * _pos + .405284735 * _pos * _pos * (_pos < 0 ? 1 : -1);\n            _sample = .225 * ((_sample < 0 ? -1 : 1) * _sample * _sample  - _sample) + _sample;\n            break;\n          case 3: // Noise\n            _sample = _noiseBuffer[Math.abs(_phase * 32 / _periodTemp | 0)];\n        }\n\n        // Applies the low and high pass filters\n        if (_filters) {\n          _lpFilterOldPos = _lpFilterPos;\n          _lpFilterCutoff *= _lpFilterDeltaCutoff;\n          if (_lpFilterCutoff < 0) {\n            _lpFilterCutoff = 0;\n          } else if (_lpFilterCutoff > .1) {\n            _lpFilterCutoff = .1;\n          }\n\n          if (_lpFilterOn) {\n            _lpFilterDeltaPos += (_sample - _lpFilterPos) * _lpFilterCutoff;\n            _lpFilterDeltaPos *= _lpFilterDamping;\n          } else {\n            _lpFilterPos = _sample;\n            _lpFilterDeltaPos = 0;\n          }\n\n          _lpFilterPos += _lpFilterDeltaPos;\n\n          _hpFilterPos += _lpFilterPos - _lpFilterOldPos;\n          _hpFilterPos *= 1 - _hpFilterCutoff;\n          _sample = _hpFilterPos;\n        }\n\n        // Applies the phaser effect\n        if (_phaser) {\n          _phaserBuffer[_phaserPos % 1024] = _sample;\n          _sample += _phaserBuffer[(_phaserPos - _phaserInt + 1024) % 1024];\n          _phaserPos++;\n        }\n\n        _superSample += _sample;\n      }\n\n      // Averages out the super samples and applies volumes\n      _superSample *= .125 * _envelopeVolume * _masterVolume;\n\n      // Clipping if too loud\n      buffer[i] = _superSample >= 1 ? 32767 : _superSample <= -1 ? -32768 : _superSample * 32767 | 0;\n    }\n\n    return length;\n  }\n}\n\n// Adapted from http://codebase.es/riffwave/\nvar synth = new SfxrSynth();\n// Export for the Closure Compiler\nvar jsfxr = function(settings) {\n  // Initialize SfxrParams\n  synth._params.setSettings(settings);\n  // Synthesize Wave\n  var envelopeFullLength = synth.totalReset();\n  var data = new Uint8Array(((envelopeFullLength + 1) / 2 | 0) * 4 + 44);\n  var used = synth.synthWave(new Uint16Array(data.buffer, 44), envelopeFullLength) * 2;\n  var dv = new Uint32Array(data.buffer, 0, 44);\n  // Initialize header\n  dv[0] = 0x46464952; // \"RIFF\"\n  dv[1] = used + 36;  // put total size here\n  dv[2] = 0x45564157; // \"WAVE\"\n  dv[3] = 0x20746D66; // \"fmt \"\n  dv[4] = 0x00000010; // size of the following\n  dv[5] = 0x00010001; // Mono: 1 channel, PCM format\n  dv[6] = 0x0000AC44; // 44,100 samples per second\n  dv[7] = 0x00015888; // byte rate: two bytes per sample\n  dv[8] = 0x00100002; // 16 bits per sample, aligned on every two bytes\n  dv[9] = 0x61746164; // \"data\"\n  dv[10] = used;      // put number of samples here\n\n  // Base64 encoding written by me, @maettig\n  used += 44;\n  var i = 0,\n      base64Characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n      output = 'data:audio/wav;base64,';\n  for (; i < used; i += 3)\n  {\n    var a = data[i] << 16 | data[i + 1] << 8 | data[i + 2];\n    output += base64Characters[a >> 18] + base64Characters[a >> 12 & 63] + base64Characters[a >> 6 & 63] + base64Characters[a & 63];\n  }\n  return output;\n}\n\nif (typeof require === 'function') {\n  module.exports = jsfxr;\n}\nelse {\n  this.jsfxr = jsfxr;\n}\n"],"names":["SfxrParams","this","setSettings","values","i","String","fromCharCode","totalTime","multiplier","synth","_envelopeLength0","_envelopeLength1","_envelopeLength2","_period","_maxPeriod","_slide","_deltaSlide","_changeAmount","_changeTime","_changeLimit","_squareDuty","_dutySweep","_params","reset","p","totalReset","synthWave","buffer","length","_filters","_hpFilterCutoff","_hpFilterDeltaCutoff","_lpFilterCutoff","_lpFilterDeltaCutoff","_lpFilterOn","_masterVolume","_minFreqency","_phaser","_phaserDeltaOffset","_phaserOffset","_repeatLimit","_sustainPunch","_vibratoAmplitude","_vibratoSpeed","_waveType","_envelopeLength","_envelopeOverLength0","_envelopeOverLength1","_envelopeOverLength2","_lpFilterDamping","_lpFilterOldPos","_periodTemp","_phaserInt","_pos","_sample","_superSample","_finished","_envelopeStage","_envelopeTime","_envelopeVolume","_hpFilterPos","_lpFilterDeltaPos","_lpFilterPos","_phase","_phaserPos","_repeatTime","_vibratoPhase","_phaserBuffer","Array","_noiseBuffer","Math","random","sin","j","n","abs","jsfxr","settings","envelopeFullLength","data","Uint8Array","used","Uint16Array","dv","Uint32Array","base64Characters","output","a","module"],"mappings":"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"}